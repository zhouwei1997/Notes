# 文本处理工具

[TOC]

## grep

> grep是行过滤工具；用于根据关键字进行过滤

### 语法和选项

语法：grep 选项 '关键字' 文件名

| 选项         | 说明                             |
| ------------ | -------------------------------- |
| -i           | 不区分大小写                     |
| -v           | 查找不包含指定内容的行，反向选择 |
| -w           | 按单词搜索                       |
| -o           | 打印匹配关键字                   |
| -c           | 统计匹配到的次数                 |
| -n           | 显示行号                         |
| -r           | 逐层遍历目录查找                 |
| -A           | 显示匹配行及后面多少行           |
| -B           | 显示匹配行及前面多少行           |
| -C           | 显示匹配行前后多少行             |
| -l           | 只列出匹配的文件名               |
| -L           | 列出不匹配的文件名               |
| -e           | 使用正则表达式                   |
| -E           | 使用正则表达式扩展               |
| ^key         | 以关键字开头                     |
| key$         | 以关键字结尾                     |
| ^$           | 匹配空行                         |
| --color=auto | 可将找到的关键词部分加上颜色显示 |

### 颜色显示

~~~shell
# 临时显示，只对当前用户有效
alias grep='grep --color=auto'

# 修改配置文件/etc/bashrc
# 在最后一行加入
alias grep='grep --color=auto'
~~~

## cut

> cut是列截取工具，用于列的截取

语法：cut [选项] 文件名

| 选项 | 说明                           |
| ---- | ------------------------------ |
| -c   | 以字符为单位进行分割，截取     |
| -d   | 自定义分割符，默认为制表符\t   |
| -f   | 与-d一起使用，指定截取那个区域 |

~~~shell
# 以：冒号分割，截取第一列内容
cut -d: -f1 1.txt

# 以：冒号分割，截取第1/6/7列内容
cut -d: -f1,6,7 1.txt

# 截取文件中每行第4个字符
cut -c4 1.txt

# 截取文件中每行第1-4个字符
cut -c1-4 1.txt

# 截取文件中每行第4-10个字符
cut -c4-10 1.txt

# 从第5个字符开始截取后面所有字符
cut -c5- 1.txt
~~~

## sort

> sort工具用于排序，它将文件的每一行作为一个单位，依次按ASCII码值进行比较，最后将它们按升序输出

| 选项 | 说明                                      |
| ---- | ----------------------------------------- |
| -u   | 去除重复行                                |
| -r   | 降序排列，默认是升序                      |
| -o   | 将排序结果输出到文件中，类似于重定向符号> |
| -t   | 分隔符                                    |
| -n   | 以数字排序，默认是按字符排序              |
| -k   | 第N行                                     |
| -b   | 忽略前导空格                              |
| -R   | 随机排序，每次运行的结果均不同            |

~~~shell
# 按用户的uid进行升序排列
sort -n -t: -k3 1.txt

# 按用户的uid进行降序排列
sort -nr -t: -k3 1.txt

# 按数字配列
sort -n 2.txt

# 按照数字列排序并且去重
sort -nu 2.txt
~~~

## uniq

> uniq用于去除连续的重复行

| 选项 | 说明           |
| ---- | -------------- |
| -i   | 忽略大小写     |
| -c   | 统计重复行次数 |
| -d   | 只显示重复行   |





## tee

> tee工具是从标准输入读取并写入标准输出和文件，即：双向覆盖重定向（屏幕输出|文本输入）

| 选项 | 说明           |
| ---- | -------------- |
| -a   | 双向追加重定向 |

~~~shell 
echo hello world | tee 11.txt
~~~

![image-20220523155724003](https://raw.githubusercontent.com/zhouwei1997/Image/master/202205231557182.png)

## diff

> diff工具用于逐行比较文本的不同

diff描述两个文件不同的方式是告诉我们怎样改变第一个文件之后和第二个文件匹配

语法：diff [选项] 文件1 文件2

| 选项 | 说明       |
| ---- | ---------- |
| -b   | 不检查空格 |
| -B | 不检查空白行 |
| -i | 忽略大小写 |
| -w | 忽略所有的空格 |
| --normal | 正常格式显示（默认） |
| -c | 上下文格式显示 |
| -u | 合并格式显示 |

### 正常模式

~~~shell
diff file1 file2

1c1,2   # 第一个文件的第一行需要改变（c=change）才能和第二个文件的第一行和第二行匹配
< aaaa # 小于号“<”表示左边（file1）文件雷人
---   # --- 表示分割符 
> aaa  # 大于号“>”表示右边文件内容
> hello
3d3   # 第一个文件的第3行删除（d=delete）后才能和第二个文件的第三行匹配
< hello world
5d4
< 333
6a6,8  # 第一个文件的第6行增加（a=add）内容后才能和第二个文件的第6/7行匹配
> 333  # 增加的内容在第二个文件里是 333 和world
> world
>
~~~

![image-20220523161220901](https://raw.githubusercontent.com/zhouwei1997/Image/master/202205231612962.png)

### 上下文格式显示

~~~shell
diff -c file1 file2

[root@yunwei01 ~]# diff -c file1 file2
# 前两行主要列出需要比较的文件名和文件时间戳，文件名前的符号***表示file1,--- 表示 file2
*** file1	2022-05-23 16:10:27.380325612 +0800
--- file2	2022-05-23 16:10:48.366289711 +0800
***************   # 分割符
*** 1,6 ****  # 以***开头表示file1文件，1,6表示1到6行
! aaaa   # ! 表示该行需要修改才能和第二个文件匹配
  111
- hello world  # - 表示该行需要修改才能和第二个文件匹配
  222
- 333
  bbb
--- 1,8 ---- # 以---开头表示file2文件，1,7表示1到7行
! aaa
! hello
  111
  222
  bbb
+ 333   # + 表示该行需要修改才能和第二个文件匹配
+ world
+ 
[root@yunwei01 ~]#
~~~

![image-20220523162200910](https://raw.githubusercontent.com/zhouwei1997/Image/master/202205231622995.png)

### 合并模式

~~~shell
diff -u file1 file2

[root@yunwei01 ~]# diff -u file1 file2
--- file1	2022-05-23 16:10:27.380325612 +0800
+++ file2	2022-05-23 16:10:48.366289711 +0800
@@ -1,6 +1,8 @@
-aaaa
+aaa
+hello
 111
-hello world
 222
-333
 bbb
+333
+world
+
[root@yunwei01 ~]#
~~~

![image-20220523162813621](https://raw.githubusercontent.com/zhouwei1997/Image/master/202205231628707.png)

需要以一个文件为标准，去修改其他的文件，并且修改的地方较多的时候，可以通过打补丁的方式进行

~~~shell
# 先找出文件的不同，然后输出到一个文件中国
diff -uN file1 file2 > file.patch
# 将不同内容打补丁到文件
patch file1 file.patch
# 测试验证
diff file1 file2
~~~

## paste

> paste工具用于合并文件行

| 选项 | 说明                    |
| ---- | ----------------------- |
| -d   | 自定义间隔符，默认是tab |
| -s   | 串行处理，非并行        |

![image-20220523164135230](https://raw.githubusercontent.com/zhouwei1997/Image/master/202205231641297.png)

![image-20220523164227704](https://raw.githubusercontent.com/zhouwei1997/Image/master/202205231643905.png)



## tr

> tr用于字符转换，替换或输出；主要用于输出文件中控制字符或进行字符转换

~~~shell
# 用法1：命令的执行结果交给tr处理，其中string1用于查询，string2用于转换处理
# commands | tr 'string1'  'string2'

# 用法2：tr处理的内容来自文件，记住要使用"<"标准输入
# tr 'string1' 'string2' < filename

# 用法3：匹配string1进行操作，如删除操作
# tr options 'string1' < filename
~~~

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -d   | 删除字符串1中所有输入字符                                    |
| -s   | 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串 |

~~~shell
# 删除文件中的：和 /
tr -d '[:/]' < 3.txt
cat 3.txt | tr -d '[:/]'
# 将文件中的数字替换为@字符
tr '[0-9]' '@' < 3.txt
# 将文件中的小写字母替换成大写字母
tr '[a-z]' '[A-Z]' < 3.txt
# 匹配小写字母并将重复的压缩为一个
tr -s '[a-z]' < 3.txt
# 匹配小写字母和数字并将重复的压缩为一个
tr -s '[a-z0-9]' < 3.txt
# 删除文件中的数字
tr -d '[:digit:]' < 3.txt
# 删除水平空白
tr -d '[:blank:]' < 3.txt
# 删除所有水平和垂直空白
tr -d '[:space:]' < 3.txt
~~~



